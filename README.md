## getopt 명령어

### 배경

잘 작성된 프로그램은 환경이나 설정 등을 가정하지 않고 사용자의 옵션(option)과 실행 인수(argument)에 따라 유연하게 다른 동작을 하도록 구현하고 있다. 프로그램에서 사용자의 옵션을 처리를 지원하기 위해 Unix 에는 전통적으로 getopt 라는 라이브러리가 있었고 개발자는 이 라이브러리를 사용하여 사용자의 입력을 처리할 수 있었다.

전통적인 유닉스의 getopt 함수는 사용자의 옵션 입력을 파싱하기 위해 옵션은 대쉬 문자(-)로 시작하고 뒤에 한 개의 옵션 문자가 오며 그 후에 실행 인수를 받을 수 있도록 설계하였다.예로 프로그램 사용을 위한 도움말을 출력하는 경우 -h 또는 -? 옵션이 입력되면 도움말을 출력하고 종료되게 구현한 경우가 많으며 버전을 확인하기 위한 옵션은 -v(또는 대문자 -V) 를 사용하고 있다.

GNU 재단은 이를 확장하여 GNU getopt 라는 라이브러리를 만들어서 GNU 의 표준 라이브러리(glibc 패키지)에 포함시켰다. GNU getopt 는 기존의 getopt 처럼 한 개의 - 로 시작하는 짧은 옵션을 처리할 수 있었고(short option 이라고 한다) 두 개의 - 로 시작하고 명령어 전체를 입력하는 긴 옵션(long option) 기능도 추가하였다. 긴 옵션을 지원하는 프로그램의 경우 도움말을 보는 옵션인 -h 또는 --help 두 가지 방식의 옵션을 모두 사용할 수가 있다.

### 설명

**getopt** 명령은 예상되는 플래그와 인수를 지정하는 형식을 사용하여 토큰 리스트를 구문 분석한다. 플래그는 단일 ASCII 문자이며 뒤에 :(콜론)이 올 경우 하나 이상의 탭 또는 공백으로 분리하거나 분리할 수 없는 인수가 있어야 한다. 인수에는 복수 바이트를 포함시킬 수 있지만 플래그 문자로는 포함시킬 수 없다.

**getopt** 명령은 모든 토큰을 읽은 후 또는 특수 토큰 -(더블 하이픈)이 발생하는 경우 처리를 완료한다. 그러면 **getopt** 명령은 처리된 플래그, -(더블 하이픈) 및 남아 있는 토큰을 출력한다.

토큰이 플래그와 일치하는 데 실패하는 경우 getopt 명령은 메시지를 표준 오류에 기록합니다.


### 구문

**getopt** optstring parameters

**getopt** [options] [--] optstring parameters

**getopt** [options] -o|--options optstring [options] [--] parameters


### 옵션

|Tag|Description|
|----|----|
|-a, --alternative|단일 '-'로 시작하는 긴 옵션을 허용한다.|
|-h, --help|도움말 텍스트를 표시하고 종료한다. 다른 출력은 생성되지 않는다.|
|-l, --longoptions *longopts*|긴(다중 문자) 옵션. 쉼표로 이름을 구분하여 두 개 이상의 옵션 이름을 동시에 지정할 수 있다.|
|-n, --name *progname*|오류를 보고할 때 getopt(3) 루틴에서 사용할 이름. getopt(1)의 오류는 여전히 getopt에서 발생하는 것으로 보고된다.|
|-o, --options *shortopts*|짧은(한 문자) 옵션. 이 옵션을 찾을 수 없으면 '-'로 시작하지 않는 getopt의 첫 번째 매개 변수가 짧은 옵션 문자열로 사용된다. shortopt의 각 짧은 옵션 문자는 필수 인수를 나타내기 위해 하나의 콜론이 뒤에 오고 선택적 인수를 나타내기 위해 두 개의 콜론이 뒤에 올 수 있다.|
|-q, --quiet|getopt(3)에 의한 오류 보고를 비활성한다.|
|-Q, --quiet-output|정상 출력을 생성하지 않는다. -q 를 사용하지 않는 한 오류는 getopt(3)에 의해 보고된다.|
|-s, -shell *shell*|셸의 따옴표 규칙을 설정한다. -s 을 사용하지 않으면 BASH 규칙이 사용된다.|
|-T, --test|getopt(1)가 이 enhanced version인지 테스트한다. 출력이 생성되지 않으며 오류 상태를 4로 설정한다.|
|-V, --version|버전 정보를 표시하고 종료한다. 다른 출력은 생성되지 않는다.|

### 예제

```sh
 #!/usr/bin/bsh
 # parse command line into arguments
 set -- `getopt a:bc $*`
 # check result of parsing
 if [ $? != 0 ]
 then
         exit 1
 fi
 while [ $1 != -- ]
 do
         case $1 in
         -a)     # set up the -a flag
                 AFLG=1
                 AARG=$2
                 shift;;
         -b)     # set up the -b flag
                 BFLG=1;;
         -c)     # set up the -c flag
                 CFLG=1;;
         esac
         shift   # next flag
 done
 shift   # skip --
 # now do the work
```



## getopts 명령어


![getopts](https://user-images.githubusercontent.com/94420917/142726714-39ac6bf2-6ead-4339-9ecb-652ca7447792.png)

### 설명

쉘 에서 명령을 실행할 때 주로 옵션을 사용한다. 스크립트 파일이나 함수를 실행할 때도 동일하게 옵션을 사용할 수 있다. 사용된 옵션은 다른 인수들과 마찬가지로 $1, $2, ... positional parameters 형태로 전달되므로 스크립트 내에서 직접 옵션을 해석해서 사용해야 된다. 이때 옵션 해석 작업을 쉽게 도와주는 명령이 **getopts** 이다. 옵션에는 short 옵션과 long 옵션이 있는데 **getopts** 명령은 short 옵션을 처리한다.

**getopts** 명령은 매개변수 리스트에서 옵션 및 옵션 인수를 검색하는 Korn/POSIX 쉘 내장 명령이다. 옵션은 + 또는 -로 시작하고 그 뒤에 문자가 나온다. + 또는 -로 시작하지 않는 옵션은 OptionString을 종료시킨다. **getopts** 명령은 호출될 때마다 Name의 다음 옵션 값과 쉘 변수 **OPTIND**에서 처리될 다음 인수의 색인을 배치한다. 쉘이 호출될 때마다 **OPTIND**는 1로 초기화된다. 옵션이 +로 시작되는 경우 +는 Name의 값 앞에 추가된다.

OptionString의 문자 뒤에는 :이 오면 옵션에 인수가 있는 것으로 간주된다. 옵션에 옵션-인수가 필요한 경우 **getopts** 명령은 이를 변수 **OPTARG**에 배치한다.

OptionString에 포함되지 않은 옵션 문자가 발견되거나 찾은 옵션에 필요한 옵션-인수가 없는 경우:

* OptionString이 :(콜론)으로 시작되지 않는 경우
    * Name은 ?(물음표) 문자로 설정된다.
    * OPTARG가 설정되지 않으며 진단 메시지가 표준 오류에 기록된다.

이 조건은 **getopts** 명령을 처리하는 중에 생긴 오류가 아니라 호출 애플리케이션에 인수가 표시되는 중에 발견된 오류라고 간주된다. 진단 메시지는 명시된 대로 기록되지만 종료 상태는 0이 된다.

* OptionString이 :(콜론)으로 시작되는 경우
    * Name은 ?(물음표)로 설정되거나 누락된 필수 옵션에 대해서는 :(콜론) 문자로 설정된다.
    * OPTARG는 발견된 옵션 문자로 설정되고 출력이 표준 오류에 기록되지 않는다.

다음 중 하나가 옵션의 끝을 식별합니다. 특수 옵션 - -,이 - 또는 +로 시작되지 않는 인수를 찾는 경우 또는 오류가 발생하는 경우.

* 옵션의 끝에 도달하는 경우:
    * getopts 명령은 0보다 큰 리턴 값으로 종료된다.
    * OPTARG는 첫 번째 비옵션-인수의 색인으로 설정된다. 여기서, 첫 번째 -- 인수는 그 전에 다른 비옵션 - 인수가 나타나지 않는 경우 옵션 - 인수로 간주되고 비옵션 - 인수가 없는 경우에는 값 $#+1로 간주된다.
    * Name은 ?(물음표) 문자로 설정된다.

### 매개변수

|항목|설명|
|----|----|
|*OptionString*|getopts 명령이 인식하는 옵션 문자의 문자열을 포함합니다. 문자 뒤에 콜론이 오는 경우 해당 옵션은 인수가 있는 것으로 간주되며 이 인수는 별도의 인수로 제공되어야 합니다. 공백을 사용하여 옵션을 인수와 분리할 수 있습니다. OptionString의 첫 번째 문자는 옵션 문자를 알 수 없거나 옵션-인수가 누락된 경우 getopts 명령이 작동하는 방식을 판별합니다.주: 물음표 및 콜론 문자는 애플리케이션에 의해 옵션 문자로 사용되어서는 안됩니다. 영숫자가 아닌 기타 문자의 사용은 지정되지 않은 결과를 생성합니다.|
|*이름*|getopts 명령에 의해 발견된 옵션 문자로 설정됩니다.|
|*Arguments...*|공백으로 분리된 하나 이상의 문자열이며 올바른 옵션인지 getopts 명령이 검사합니다. Argument가 생략되는 경우 위치 매개변수가 사용됩니다.주: 일반적으로 Argument를 getopts 명령의 일부로 지정하지 않지만 스크립트를 디버깅할 때 이를 지정하는 것은 유용할 수 있습니다.|
    
### 종료 상태
|항목|설명|
|----|----|
|0|OptionString에 의해 지정되거나 지정되지 않은 옵션이 발견되었습니다.|
|> 0|옵션의 끝에 도달했거나 오류가 발생했습니다.|
    
### 예제

1. 다음 getopts 명령은 a, b 및 c가 유효한 옵션이고 a 및 c 옵션에 인수가 있음을 지정합니다.

    `getopts a:bc: OPT`

2. 다음 getopts 명령은 a, b 및 c가 유효한 옵션이고 a 및 b 옵션에는 인수가 있으며 명령행에서 정의되지 않은 옵션을 발견하는 경우 getopts가 OPT의 값을 ?로 설정하도록 지정합니다.

    `getopts :a:b:c OPT`

3. 다음 스크립트가 인수를 구문 분석하고 표시합니다.
    ```sh
        aflag=
        bflag=

        while getopts ab: name
        do
                    case $name in
                    a)     aflag=1;;
                    b)     bflag=1
                                  bval="$OPTARG";;
                    ?)     printf "Usage: %s: [-a] [-b value] args\n" $0
                                  exit 2;;
                   esac
        done

        if [ ! -z "$aflag" ]; then
                   printf "Option -a specified\n"
        fi

        if [ ! -z "$bflag" ]; then
                   printf 'Option -b "%s" specified\n' "$bval"
        fi

        shift $(($OPTIND -1))
        printf "Remaining arguments are: %s\n" "$*"
    ```



## sed 명령어



## awk 명령어

### 용도
파일에서 패턴이 일치하는 행을 찾아서 그 행에 지정한 조치를 수행한다.

### 구문
awk [-F sepstring] [-v assignment] ... program [argument...]

awk [-F sepstring] -f progfile [-f progfile]... [-v assignment] ... [argument...]

### 설명
awk 명령은 사용자가 제공하는 명령어 세트를 사용하여 사용자가 제공한 확장 정규식과 파일 세트를 한 번에 한 행씩 비교합니다. 그런 다음, 확장 정규식과 일치하는 모든 행에서 조치를 실행합니다.

awk 명령의 패턴 검색은 grep 명령의 패턴 검색보다 더 일반적이고, 이 경우 사용자는 입력 텍스트 행에 대해 여러 가지 조치를 실행할 수 있습니다. awk 명령 프로그래밍 언어에는 컴파일이 필요하지 않으며, 사용자는 변수, 숫자 함수, 문자열 함수, 논리적 연산자를 사용할 수 있습니다.

### 입력
awk 명령은 두 종류의 입력, 입력 텍스트 파일과 프로그램 명령어를 사용합니다.
 - 입력 테스트 파일 : 검색과 조치는 입력 텍스트 파일에서 실행됩니다. 파일은 다음 방식으로 지정됩니다.

    명령행에서 File 변수를 지정합니다.
    특수 변수 ARGV 및 ARGC를 수정합니다.
    File 변수가 없으면 표준 입력을 제공합니다.
    File 변수에 여러 파일이 지정된 경우 파일은 지정된 순서대로 처리됩니다.
    
 - 프로그램 명령어

    사용자가 제공하는 명령어는 awk 명령의 조치를 제어합니다. 이 명령어는 명령행의 `Program' 변수에서 가져오거나 ProgramFile 변수와 함께 사용된 -f 플래그로 지정한 파일에서 가져옵니다. 여러 프로그램 파일이 지정되면, 파일은 지정된 순서에 따라 병합되고 그 결과로 생성되는 명령어의 순서가 사용됩니다.

### 출력
awk 명령은 입력 텍스트 파일에 있는 데이터로부터 세 가지 종류의 결과를 출력합니다.

- 선택된 데이터는 입력 파일을 변경하지 않고 표준 출력으로 인쇄될 수 있습니다.
- 입력 파일 중 선택된 부분을 변경할 수 있습니다.
- 선택된 데이터는 입력 파일 컨텐츠 변경 여부와는 상관없이 변경되고 표준 출력으로 출력될 수 있습니다.

이러한 종류의 출력은 모두 같은 파일에서 수행될 수 있습니다. awk 명령이 인식하는 프로그래밍 언어를 통해 사용자는 출력 방향을 재지정할 수 있습니다.

### 패턴
1) 정규식
    awk 명령에서 사용하는 확장 정규식은 grep 또는 egrep 명령에서 사용하는 정규식과 비슷합니다. 가장 간단한 양식의 확장 정규식은 슬래시 기호로 묶은 문자열입니다. 예를 들어, testfile이라는 이름의 파일에 다음 컨텐츠가 있다고 가정합니다.
    ```
        smawley, andy
        smiley, allen
        smith, alan
        smithern, harry
        smithhern, anne
        smitters, alexis
    ```
    
    다음 명령행을 입력합니다.

    `awk '/smi/' testfile`
    
    그러면 문자열 smi의 발생을 포함하는 모든 레코드의 표준 출력으로 인쇄합니다. 이 예제에서, awk 명령에 대한 '/smi/' 프로그램은 조치가 없는 패턴입니다. 결과는 다음과 같습니다.
    
    ```
        smiley, allen
        smith, alan
        smithern, harry
        smithhern, anne
        smitters, alexis
    ```

2) 관계식
    관계 연산자 <(보다 작음), >(보다 큼), <=(작거나 같음), >=(크거나 같음), = =(같음) 그리고 ! =(같지 않음)은 패턴을 만드는 데 사용할 수 있습니다. 예를 들어, 다음과 같습니다.
    `$1 < $4`

    이 패턴은 첫 번째 필드가 네 번째 필드보다 작은 레코드와 일치합니다. 관계 연산자는 문자열 값과도 사용할 수 있습니다. 예:


    `$1 =! "q"`

    이 패턴은 첫 번째 필드가 q가 아닌 모든 레코드와 일치합니다. 배열 값에서 문자열 값을 일치시킬 수도 있습니다. 예:


    `$1 >= "d"`

    이 패턴은 첫 번째 필드가 a, b, c 또는 d인 문자로 시작되는 모든 레코드와 일치합니다. 다른 정보를 제공하지 않은 경우 필드 변수는 문자열 값으로 비교됩니다.
    
3) 패턴의 조합
    세 가지 옵션을 사용해 패턴을 결합할 수 있습니다.

    범위는 ,(쉼표)로 구분된 두 패턴으로 지정됩니다. 첫 번째 패턴과 일치하는 레코드로 시작하여 두 번째 패턴과 일치하는 레코드를 포함하여 계속되는 모든 레코드에서 조치가 수행됩니다. 예:
    `/begin/,/end/`

    이 패턴은 문자열 begin을 포함하는 레코드, 이 문자열과 문자열 end를 포함하는 레코드 사이의 모든 레코드(문자열 end를 포함하는 레코드 포함)와 일치합니다.
    
    괄호( )는 패턴을 함께 그룹화합니다.
    
    부울 연산자 ||(또는), &&(및), ! (부정)는 true로 평가되는 경우 일치하는 표현식에 패턴을 결합합니다. true가 아니면 이들은 일치하지 않습니다. 예를 들어, 다음과 같습니다.

    `$1 == "al" && $2 == "123"`

    이 패턴은 첫 번째 필드가 al이고 두 번째 필드가 123인 레코드와 일치합니다.

4) BEGIN 및 END 패턴
    BEGIN 패턴으로 지정된 조치는 모든 입력을 읽기 전에 수행됩니다. END 패턴으로 지정된 조치는 모든 입력을 읽은 후에 수행됩니다. 여러 개의 BEGIN 및 END 패턴이 허용되고, 지정된 순서대로 처리됩니다. 프로그램 명령문에서 END 패턴이 BEGIN 패턴 앞에 올 수 있습니다. 프로그램이 BEGIN문만으로 구성된 경우, 조치가 수행되며 어떠한 입력도 읽지 않습니다. 프로그램이 END문만으로 구성된 경우, 모든 입력은 조치를 취하기 전에 읽습니다.

### 조치
1) 조치문
    조치문은 { }(중괄호)로 묶습니다. 패턴 없이 명령문이 지정되면, 조치는 모든 레코드에서 실행됩니다. 중괄호 안에 다중 조치를 지정할 수 있습니다. 그러나 각 조치는 줄 바꾸기 문자 또는 ;(세미콜론)으로 구분되어야 하고, 명령문은 나타나는 순서대로 처리됩니다. 조치문은 다음을 포함하고 있습니다.

2) 내장 함수
    awk 명령 언어는 산술 함수, 문자열 함수, 일반 함수를 사용합니다. 파일을 작성하고 이 파일을 나중에 같은 프로그램에서 읽으려면 close 서브루틴문이 있어야 합니다.
    1) 산술 함수
    2) 문자열 함수
    3) 일반 함수

3) 사용자 정의 함수

4) 조건문
    awk 명령 프로그래밍 언어에서 대부분의 조건문은 C 프로그래밍 언어의 조건문과 구문 및 기능이 동일합니다. 모든 조건문은 명령문을 그룹화하기 위해 { }(중괄호)의 사용을 허용합니다. 조건문의 표현식 부분과 명령문 부분 사이에 선택적으로 줄 바꾸기를 사용할 수 있으며, 줄 바꾸기 또는 ;(세미콜론)을 사용하여 { }(중괄호) 안에서 다중 명령문을 구분합니다. C 언어에는 다음과 같은 여섯 가지 조건문이 있습니다.

5) 출력문

### 플래그
|항목|설명|
|----|-----|
|-f *ProgramFile*|*ProgramFile* 변수로 지정된 파일로부터 awk 명령에 대한 명령어를 얻습니다. -f 플래그가 여러 번 지정되면 지정된 순서로 병합된 파일이 명령어 세트로 사용됩니다.|
|-u|버퍼링되지 않은 모드로 출력을 표시합니다. 이 플래그를 사용하면 awk 명령을 출력을 버퍼링하지 않습니다. 대신, 즉시 출력을 표시합니다. 기본적으로 awk 명령은 버퍼링된 모드로 출력을 표시합니다.|
|-F *Ere*|*Ere* 변수로 지정된 확장 정규식을 필드 구분자로 사용합니다. 디폴트 필드 구분자는 공백입니다.|
|-v *Assignment*|awk 명령의 프로그래밍 언어에서 변수에 값을 지정합니다. *Assignment* 매개변수는 *Name = Value* 양식입니다. *Name* 부문은 변수 이름을 지정하고, 밑줄, 숫자, 영문자의 조합일 수 있습니다. 단, 밑줄 또는 영문자로 시작해야 합니다. *Value* 부분도 밑줄, 숫자, 영문자로 구성되며, 앞뒤에 "(문자열 값과 비슷하게 이중 인용 부호)가 있는 경우처럼 처리됩니다. *Value* 부분이 숫자인 경우, 변수에도 숫자 값이 지정됩니다.-v 플래그에 의해 지정된 지정은 BEGIN 섹션을 포함하여 awk 명령 프로그램의 일부가 실행되기 전에 수행됩니다.|
|*Assignment*|awk 명령의 프로그래밍 언어에서 변수에 값을 지정합니다. 각각 처리되는 시간을 제외하고 -v 플래그를 포함하는 *Assignment* 변수와 양식 및 기능이 동일합니다. *Assignment* 매개변수는 명령행에서 이 뒤에 나오는 입력 파일(File 변수로 지정됨) 바로 앞에서 처리됩니다. *Assignment* 매개변수가 여러 입력 파일의 첫 번째 파일 바로 앞에 지정되면 지정은 BEGIN 섹션(있는 경우) 바로 뒤에서 처리됩니다. 마지막 파일 이후에 *Assignment* 매개변수가 나타나면 END 섹션(있는 경우) 전에 지정이 처리됩니다. 입력 파일이 지정되지 않은 경우, 지정이 처리되고 표준 입력을 읽습니다.|
|*File*|처리를 위한 입력을 포함하고 있는 파일 이름을 지정합니다. *File* 변수가 지정되지 않거나 -(빼기) 기호가 지정된 경우 표준 입력이 처리됩니다.|
|'*Program*'|awk 명령에 대한 명령어를 포함합니다. -f 플래그를 지정하지 않은 경우 *Program* 변수는 명령행의 첫 번째 항목이어야 합니다. 이는 ' '(단일 인용 부호)로 묶어야 합니다.|

### 종료 상태
|항목|설명|
|----|----|
|0|성공적으로 완료되었다.|
|> 0|오류가 발생했다.|

exit [ Expression ] 조건문을 사용하여 프로그램 내에서 종료 상태를 변경할 수 있습니다.

### 예제
1) 72자보다 긴 파일 행을 표시하려면 다음을 입력하십시오.

```
    awk  'length  >72'  chapter1
```

이 명령은 chapter1 파일에서 72자보다 긴 각 행을 선택하여 이 행을 표준 출력으로 작성합니다. Action이 지정되지 않았기 때문입니다. 탭 문자는 1바이트로 계산됩니다.

2) 단어 start 및 stop 사이의 모든 행을 표시하려면( "start" 및 "stop" 포함) 다음을 입력하십시오.

```
    awk  '/start/,/stop/'  chapter1
```

3) chapter1 파일을 처리하는 awk 명령 프로그램, sum2.awk를 실행하려면 다음을 입력하십시오.

```
    awk  -f  sum2.awk  chapter1
```

다음 프로그램, sum2.awk는 입력 파일, chapter1의 두 번째 열에서 숫자의 합계와 평균을 계산합니다.

```
        {
           sum += $2
        }
    END {
           print "Sum: ", sum;
           print "Average:", sum/NR;
        }
```

첫 번째 조치는 각 행의 두 번째 필드 값을 변수 sum에 더합니다. 모든 변수는 처음 참조될 때 0(영) 숫자 값으로 초기화됩니다. 두 번째 조치 앞에 나오는 END 패턴으로 해당 조치는 입력 파일 모두를 읽은 후에 수행됩니다. 평균을 계산하기 위하여 사용되는 NR 특별 변수는 읽은 레코드의 수를 지정하는 특별 변수입니다.

4) 반대 순서로 처음 두 개 필드를 인쇄하려면 다음을 입력하십시오.

```
    awk '{ print $2, $1 }' chapter1
```

5) 다음의 awk 프로그램의 경우:

```
    awk -f sum3.awk chapter2
```

쉼표 및/또는 공백과 탭으로 입력 파일을 구분하여 파일 chapter2의 처음 두 개 필드를 인쇄하고 첫 번째 열을 더하고 합계와 평균을 인쇄합니다.
```
    BEGIN  {FS = ",|[ \t]+"}
           {print $1, $2}
           {s += $1}
    END    {print "sum is",s,"average is", s/NR }      
```











